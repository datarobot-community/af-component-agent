# Copyright 2025 DataRobot, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import asyncio
import os
import re
from pathlib import Path
from typing import Any, Optional, Union

from helpers import create_inputs_from_completion_params
from nat.runtime.loader import load_workflow
from nat.utils.type_utils import StrPath
from openai.types.chat import CompletionCreateParams


class MyAgent:
    """MyAgent is a custom agent that uses NVIDIA NeMo Agent Toolkit to implement a react agent
    with basic mathematical tools available.
    It utilizes DataRobot's LLM Gateway or a specific deployment for language model interactions.
    This example illustrates 3 agents that handle content creation tasks, including planning, writing,
    and editing blog posts.
    """

    def __init__(
        self,
        api_key: Optional[str] = None,
        api_base: Optional[str] = None,
        model: Optional[str] = None,
        workflow_file_name: Optional[str] = None,
        verbose: Optional[Union[bool, str]] = True,
        timeout: Optional[int] = 90,
        **kwargs: Any,
    ):
        """Initializes the MyAgent class with API key, base URL, model, and verbosity settings.

        Args:
            api_key: Optional[str]: API key for authentication with DataRobot services.
                Defaults to None, in which case it will use the DATAROBOT_API_TOKEN environment variable.
            api_base: Optional[str]: Base URL for the DataRobot API.
                Defaults to None, in which case it will use the DATAROBOT_ENDPOINT environment variable.
            model: Optional[str]: The LLM model to use.
                Defaults to None.
            workflow_file_name: Optional[str]: The NAT workflow file to use.
                Defaults to None.
            verbose: Optional[Union[bool, str]]: Whether to enable verbose logging.
                Accepts boolean or string values ("true"/"false"). Defaults to True.
            timeout: Optional[int]: How long to wait for the agent to respond.
                Defaults to 90 seconds.
            **kwargs: Any: Additional keyword arguments passed to the agent.
                Contains any parameters received in the CompletionCreateParams.

        Returns:
            None
        """
        self.api_key = api_key or os.environ.get("DATAROBOT_API_TOKEN")
        self.api_base = api_base or os.environ.get("DATAROBOT_ENDPOINT")
        self.model = model
        self.workflow_file_name = workflow_file_name or os.environ.get(
            "WORKFLOW_FILE_NAME", "nat-workflow.yaml"
        )
        self.timeout = timeout
        if isinstance(verbose, str):
            self.verbose = verbose.lower() == "true"
        elif isinstance(verbose, bool):
            self.verbose = verbose

    @property
    def api_base_litellm(self) -> str:
        """Returns a modified version of the API base URL suitable for LiteLLM.

        Strips 'api/v2/' or 'api/v2' from the end of the URL if present.

        Returns:
            str: The modified API base URL.
        """
        if self.api_base:
            return re.sub(r"api/v2/?$", "", self.api_base)
        return "https://api.datarobot.com"

    async def run_nat_workflow(self, config_file: StrPath, input_str: str) -> str:
        """Run the NAT workflow with the provided config file and input string.

        Args:
            config_file: Path to the NAT workflow configuration file
            input_str: Input string to process through the workflow

        Returns:
            str: The result from the NAT workflow
        """
        async with load_workflow(config_file) as workflow:
            async with workflow.run(input_str) as runner:
                return await runner.result(to_type=str)  # type: ignore[no-any-return]

    def run(
        self, completion_create_params: CompletionCreateParams
    ) -> tuple[str, dict[str, int]]:
        """Run the agent with the provided completion parameters.

        [THIS METHOD IS REQUIRED FOR THE AGENT TO WORK WITH DRUM SERVER]

        Inputs can be extracted from the completion_create_params in several ways. A helper function
        `create_inputs_from_completion_params` is provided to extract the inputs as json or a string
        from the 'user' portion of the input prompt. Alternatively you can extract and use one or
        more inputs or messages from the completion_create_params["messages"] field.

        Args:
            completion_create_params (CompletionCreateParams): The parameters for
                the completion request, which includes the input topic and other settings.
        Returns:
            tuple[str, dict[str, int]]: A tuple containing the response string and the agent output.

        """
        # Example helper for extracting inputs as a json from the completion_create_params["messages"]
        # field with the 'user' role: (e.g. {"topic": "Artificial Intelligence"})
        inputs = create_inputs_from_completion_params(completion_create_params)

        # Convert inputs to str
        if isinstance(inputs, str):
            input_str = inputs
        else:
            # If inputs is a dict, convert to string representation or extract relevant field
            input_str = str(inputs)

        # Print commands may need flush=True to ensure they are displayed in real-time.
        print("Running NAT agent with inputs:", input_str, flush=True)

        # Get the config file path
        config_file = Path(__file__).parent / self.workflow_file_name  # type: ignore[operator]

        # Run the NAT workflow
        try:
            result = asyncio.run(self.run_nat_workflow(config_file, input_str))
        except Exception as e:
            print(f"Error running NAT workflow: {e}", flush=True)
            result = f"Error: {str(e)}"

        usage_metrics: dict[str, int] = {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
        }
        return result, usage_metrics
