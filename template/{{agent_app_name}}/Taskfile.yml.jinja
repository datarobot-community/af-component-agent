---
# https://taskfile.dev
version: '3'
vars:
  NAT_LOG_LEVEL: '{% raw %}{{default "info" .NAT_LOG_LEVEL}}{% endraw %}'
  # Cross-platform environment cleaning - uses 'env -u' on Unix systems, falls back to empty string on Windows
  UV_CMD:
    sh: |
      # This command ensures compatibility with codespaces environments
      # Cross-platform environment cleaning - uses 'env -u' on Unix systems,
      # falls back to empty string on Windows
      if command -v env >/dev/null 2>&1; then
        echo "env -u PYTHONPATH -u VIRTUAL_ENV uv"
      else
        echo "uv"
      fi
tasks:
  install:
    desc: ðŸ› ï¸ Install agent uv dependencies
    cmds:
      - echo "Updating local dependencies for {{ agent_app_name }}"
      - "{% raw %}{{.UV_CMD}}{% endraw %} sync --extra dev"
      - if [ -f pyproject.toml ] && [ -d docker_context ]; then cp pyproject.toml docker_context/pyproject.toml; fi
      - if [ -f uv.lock ] && [ -d docker_context ]; then cp uv.lock docker_context/uv.lock; fi
    aliases:
      - req
  update:
    # Hidden to avoid showing in task list, run `task --list-all` to see it
    # desc: ðŸ› ï¸ Update local dependencies (refresh uv locks)
    cmds:
      - echo "Updating local dependencies for {{ agent_app_name }}"
      - "{% raw %}{{.UV_CMD}}{% endraw %} sync --extra dev -U"
    silent: true
  auth-check:
    silent: true
    desc: "ðŸ” Check authentication prerequisites"
    cmds:
      - |
        if command -v dr &> /dev/null && dr auth help 2>&1 | grep -q "check"; then
          echo "ðŸ” Checking authentication.."
          dr auth check
        else
          echo "â„¹ï¸  Skipping auth check (not available)"
        fi
  add-dependency:
    desc: ðŸ› ï¸ Add provided packages as a new dependency to an agent
    cmds:
      - echo "Adding new dependency for {{ agent_app_name }} into 'extras' dependency group"
      - "{% raw %}{{.UV_CMD}}{% endraw %} add --no-upgrade --group extras {% raw %}{{.CLI_ARGS}}{% endraw %}"
    silent: true
  lint:
    # Hidden to avoid showing in task list, run `task --list-all` to see it
    # desc: ðŸ§¹ Lint the codebase
    cmds:
      - task: req
      - echo "Linting the codebase"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run ruff check . --fix"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run ruff format ."
      - "{% raw %}{{.UV_CMD}}{% endraw %} run mypy --pretty ."
      - "{% raw %}{{.UV_CMD}}{% endraw %} run yamlfix . -e '.venv/**/*.yaml' -e '.venv/**/*.yml' -e 'build/**/*.yaml' -e 'build/**/*.yml'"
    silent: true
  lint-check:
    # Hidden to avoid showing in task list, run `task --list-all` to see it
    # desc: ðŸ§¹ Check whether the codebase is linted
    cmds:
      - task: req
      - echo "Checking linting"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run ruff format --check --diff ."
      - "{% raw %}{{.UV_CMD}}{% endraw %} run ruff check --diff ."
      - echo "Checking type hints"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run mypy --pretty ."
    silent: true
  test:
    # Hidden to avoid showing in task list, run `task --list-all` to see it
    # desc: ðŸ§ª Run tests
    cmds:
      - echo "Running pytest on tests"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run pytest -vv ./tests/"
    silent: true
  test-coverage:
    # Hidden to avoid showing in task list, run `task --list-all` to see it
    # desc: ðŸ§ª Run tests with coverage
    cmds:
      - echo "Running pytest on tests"
      - "{% raw %}{{.UV_CMD}}{% endraw %} run pytest -vv --cov --cov-report=html --cov-report=term --cov-report xml:.coverage.xml ./tests/"
    silent: true
  cli:
    desc: ðŸ–¥ï¸ Run the CLI with provided arguments
    vars:
      START_DEV: "{% raw %}{{.START_DEV}}{% endraw %}"
    deps:
      - auth-check
    cmds:
      - echo "Running CLI {% raw %}{{.CLI_ARGS}}{% endraw %}"
      - |
        if [ "{% raw %}{{.START_DEV}}{% endraw %}" -eq "1" ]; then
          # Kill any existing dev server processes
          pkill -f '{% raw %}{{.UV_CMD}}{% endraw %} run python dev.py' 2>/dev/null || true

          # Start dev server in background
          echo "ðŸš€ Starting dev server in background..."
          {% raw %}{{.UV_CMD}}{% endraw %} run python dev.py &
          DEV_SERVER_PID=$!
          echo "Dev server started with PID: $DEV_SERVER_PID"

          # Wait for server to be ready
          echo "â³ Waiting for dev server to be ready..."
          _AGENT_PORT="8842"
          if [ -n "${{ agent_app_name | upper }}_PORT" ]; then
            _AGENT_PORT="${{ agent_app_name | upper }}_PORT"
          fi
          _AGENT_ENDPOINT="http://localhost:$_AGENT_PORT"
          i=0
          while [ $i -lt 30 ]; do
            if curl --silent --fail --max-time 2 "$_AGENT_ENDPOINT/" >/dev/null 2>&1; then
              echo "âœ… Dev server is ready!"
              break
            fi
            sleep 1
            i=$((i + 1))
            if [ $i -eq 30 ]; then
              echo "âŒ Dev server failed to start within 30 seconds"
              pkill -f '{% raw %}{{.UV_CMD}}{% endraw %} run python dev.py' 2>/dev/null || true
              exit 1
            fi
          done
        fi
      - |
        # Run CLI and handle cleanup regardless of exit code
        CLI_EXIT_CODE=0
        UV_PROJECT={% raw %}{{.TASKFILE_DIR}}{% endraw %} {% raw %}{{.UV_CMD}}{% endraw %} run cli.py {% raw %}{{.CLI_ARGS}}{% endraw %} || CLI_EXIT_CODE=$?
        echo "CLI exited with code: $CLI_EXIT_CODE"

        # Check if command failed and contains "execute"
        if [ $CLI_EXIT_CODE -eq 1 ] && echo "{% raw %}{{.CLI_ARGS}}{% endraw %}" | grep -q "execute "; then
          echo ""
          echo "âŒ CLI command failed with exit status 1"
          echo "ðŸ’¡ It looks like you're trying to execute an agent that requires a dev server."
          echo "   Try one of these options:"
          echo "   1. Start the dev server first: task {{ agent_app_name }}:dev"
          echo "   2. Or run with auto dev server: task {{ agent_app_name }}:cli START_DEV=1 -- {% raw %}{{.CLI_ARGS}}{% endraw %}"
          echo ""
        fi

        # Clean up dev server processes if we started them
        if [ "{% raw %}{{.START_DEV}}{% endraw %}" -eq "1" ]; then
          echo "ðŸ›‘ Stopping dev server..."
          pkill -f '{% raw %}{{.UV_CMD}}{% endraw %} run python dev.py' 2>/dev/null || true
          echo "âœ… Dev server stopped"
        fi

        exit $CLI_EXIT_CODE
    silent: true
  dev:
    desc: ðŸ”¨ Run the development server
    deps:
      - auth-check
    cmds:
      - |
        if [ "$ENABLE_NAT_SERVER" -eq "1" ]; then
          ROOT_PATH_ARG=""; [ -n "${URL_PREFIX:-}" ] && ROOT_PATH_ARG="--root_path ${URL_PREFIX}"; {% raw %}{{.UV_CMD}}{% endraw %} run nat --log-level {% raw %}{{.NAT_LOG_LEVEL}}{% endraw %} start dragent_fastapi --config_file agent/workflow.yaml --reload true --port $AGENT_PORT $ROOT_PATH_ARG
        else
          {% raw %}{{.UV_CMD}}{% endraw %} run python dev.py --autoreload
        fi
    silent: true
  dev-stop:
    desc: ðŸ›‘ Stop the development server
    cmds:
      - echo "Stopping development server"
      - pkill -f '{% raw %}{{.UV_CMD}}{% endraw %} run python dev.py' 2>/dev/null || echo "No development server process found"
  create-docker-context:
    desc: ðŸ³ Create the template for a local docker_context image
    vars:
      BRANCH: "{% raw %}{{.BRANCH}}{% endraw %}"
    cmds:
      - echo "Creating docker_context folder inside agent."
      - rm -rf ./docker_context
      - echo "Downloading datarobot-user-models repository..."
      - |
        GIT_BRANCH={% raw %}{{.BRANCH}}{% endraw %}
        if [ -n "$GIT_BRANCH" ]; then
          echo "Downloading datarobot-user-models branch: $GIT_BRANCH"
          curl -L -o datarobot-user-models.zip "https://github.com/datarobot/datarobot-user-models/archive/refs/heads/$GIT_BRANCH.zip"
        else
          echo "Downloading datarobot-user-models master branch"
          curl -L -o datarobot-user-models.zip "https://github.com/datarobot/datarobot-user-models/archive/refs/heads/master.zip"
        fi
      - echo "Extracting docker_context files..."
      - |
        TOP_FOLDER=$(unzip -qql datarobot-user-models.zip | head -n1 | awk '{print $4}' | cut -d/ -f1)
        echo "Downloaded docker context branch name: $TOP_FOLDER"
        unzip -q datarobot-user-models.zip "$TOP_FOLDER/public_dropin_environments/python311_genai_agents/*"
        cp -r "$TOP_FOLDER/public_dropin_environments/python311_genai_agents" ./docker_context
        rm -rf "$TOP_FOLDER" datarobot-user-models.zip
      # We need to rename these from their production variants to their local variants
      - rm ./docker_context/env_info.json
      - mv ./docker_context/Dockerfile ./docker_context/Dockerfile.prod
      - mv ./docker_context/Dockerfile.local ./docker_context/Dockerfile
      - echo "Docker context created inside {{ agent_app_name }}/docker_context"
  build-docker-image:
    # desc: ðŸ³ Build the Docker image
    cmds:
      - echo "Building Docker image"
      - cp pyproject.toml docker_context/pyproject.toml
      - cd docker_context && docker build --platform linux/amd64 -f Dockerfile -t {{ agent_app_name }}:latest .
  build-docker-context:
    desc: ðŸ³ Build the Docker image
    cmds:
      - task: create-docker-context
      - echo "Saving Docker image"
      - docker save {{ agent_app_name }}:latest | gzip -1 > docker_context.tar.gz
    silent: true
